'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var WebSocket = require("ws");
var events = require("events");
var websockets = require('./websockets');
var PolygonWebsocket = /** @class */ (function (_super) {
    __extends(PolygonWebsocket, _super);
    function PolygonWebsocket(apiKey, session) {
        var _this = _super.call(this) || this;
        _this._apiKey = apiKey;
        _this.session = session;
        _this.connectCalled = false;
        _this.channels = [];
        return _this;
    }
    PolygonWebsocket.prototype.connect = function (initialChannels) {
        var _this = this;
        this.channels = initialChannels;
        this.reconnectDisabled = false;
        this.connectCalled = true;
        this.emit(websockets.STATE.CONNECTING);
        this.conn = new WebSocket(process.env.DATA_PROXY_WS ||
            'wss://socket.polygon.io/stocks');
        var connectListener = function () { _this.subscribe(initialChannels); };
        this.on(websockets.STATE.CONNECTED, connectListener);
        this.conn.once("open", function () {
            _this.authenticate();
        });
        this.conn.on("message", function (data) { return _this.handleMessage(data); });
        this.conn.once("error", function (err) {
            _this.emit(websockets.ERROR.CONNECTION_REFUSED);
        });
        this.conn.once("close", function () {
            _this.removeListener(websockets.STATE.CONNECTED, connectListener);
            _this.emit(websockets.STATE.DISCONNECTED);
            if (_this.session.reconnect && !_this.reconnectDisabled) {
                _this.reconnect();
            }
        });
    };
    PolygonWebsocket.prototype.handleMessage = function (data) {
        var _this = this;
        // Heartbeat
        var bytes = new Uint8Array(data);
        if (bytes.length === 1 && bytes[0] === 1) {
            return;
        }
        var messageArray = JSON.parse(data);
        messageArray.forEach(function (message) {
            var subject = message.ev;
            switch (subject) {
                case "status":
                    switch (message.status) {
                        case "auth_success":
                            _this.emit(websockets.STATE.CONNECTED);
                            _this.authenticating = false;
                            break;
                        case "auth_failed":
                            _this.emit(websockets.ERROR.BAD_KEY_OR_SECRET);
                            _this.authenticating = false;
                            _this.close();
                            break;
                    }
                    break;
                case "Q":
                    _this.emit(websockets.EVENT.STOCK_QUOTES, subject, data);
                    break;
                case "T":
                    _this.emit(websockets.EVENT.STOCK_TRADES, subject, data);
                    break;
                case "A":
                    _this.emit(websockets.EVENT.STOCK_AGG_SEC, subject, data);
                    break;
                case "AM":
                    _this.emit(websockets.EVENT.STOCK_AGG_MIN, subject, data);
                    break;
                default:
                    _this.emit(websockets.ERROR.PROTOBUF);
            }
        });
    };
    PolygonWebsocket.prototype.send = function (data) {
        this.conn.send(data);
    };
    PolygonWebsocket.prototype.authenticate = function () {
        this.authenticating = true;
        this.emit(websockets.STATE.AUTHENTICATING);
        var authMsg = {
            action: 'auth',
            params: this._apiKey
        };
        this.send(JSON.stringify(authMsg));
    };
    PolygonWebsocket.prototype.subscribe = function (topics) {
        var subMsg = {
            action: 'subscribe',
            params: topics.join(',')
        };
        this.send(JSON.stringify(subMsg));
        this.channels = this.channels.concat(topics);
    };
    PolygonWebsocket.prototype.unsubscribe = function (topics) {
        var subMsg = {
            action: 'unsubscribe',
            params: topics.join(',')
        };
        console.log(JSON.stringify(subMsg));
        this.send(JSON.stringify(subMsg));
        this.channels = this.channels.filter(function (e) { return topics.indexOf(e) == -1; });
    };
    PolygonWebsocket.prototype.close = function () {
        this.connectCalled = false;
        this.reconnectDisabled = true;
        if (this.conn) {
            this.conn.close();
        }
    };
    PolygonWebsocket.prototype.reconnect = function () {
        var _this = this;
        console.log('Attempting Polygon websocket reconnection...');
        setTimeout(function () {
            if (_this.session.backoff) {
                _this.session.reconnectTimeout += _this.session.backoffIncrement;
                if (_this.session.reconnectTimeout > _this.session.maxReconnectTimeout) {
                    _this.session.reconnectTimeout = _this.session.maxReconnectTimeout;
                }
            }
            _this.connect(_this.channels);
        }, this.session.reconnectTimeout * 1000);
        this.emit(websockets.STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout);
    };
    return PolygonWebsocket;
}(events.EventEmitter));
exports.PolygonWebsocket = PolygonWebsocket;
